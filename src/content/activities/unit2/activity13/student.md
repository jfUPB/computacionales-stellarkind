## Solución a la decimotercer  actividad
En esta unidad, me enfoqué en profundizar en la programación en C++ y en ensamblador, dos lenguajes que operan a niveles muy diferentes. Aprendí a implementar programas básicos en ambos lenguajes, como la serie de 
Fibonacci en C++ y su equivalente en ensmblador.

### Conceptos más desafiantes
Uno de los conceptos más complicados fue entender la gestión manual de la memoria y el control de flujo sin las estructuras de alto nivel a las que estoy acostumbrado construyendo primero en alto nivel.
Por ejemplo, en C++, puedo simplemente escribir un bucle for para calcular Fibonacci, pero en Hack, tuve que manejar cada paso del bucle manualmente, usando saltos condicionales y actualizaciones directas de registros.

### Estrategias para comprender conceptos desafiantes
Para abordar estos desafíos, dividí cada problema en partes más pequeñas. Primero, aseguré entender cada línea de C++ y asegurarme que funcionasecomo quería antes de intentar implementar su lógica en ensamblador.
Además, usé el tabulador en el código para recordar mejor que representaba cada sección del código, especialmente en ensamblador.

### Estrategias más efectivas
La estrategia más efectiva fue la práctica constante acompañada de mucha lectura de documentación y ejemplos de código. Realizar ejercicios prácticos me ayudó a solidificar mi comprensión de cómo funcionan 
las instrucciones a bajo nivel y cómo se relacionan con conceptos de más alto nivel en C++. También, ejeciutar el código paso a paso en un simulador fue crucial para ver exactamente cómo cambian los valores en los 
registros y la memoria, lo cual fue invaluable para entender realmente lo que estaba haciendo mi código.

Estas experiencias y estrategias no solo mejoraron mi habilidad para trabajar con estos lenguajes, sino que también profundizaron mi comprensión general de la programación y cómo diferentes niveles de abstracción afectan lógica de los programas.





